#include <stdio.h>
#include <string.h>

#include "stm8l15x_conf.h"
#include "MyNBIOT.h"
#include "stm8l15x_it.h"
#include "Common.h"
#include "eemFlash.h"
#include "McuTarger.h"
#include "zigbee.h"
#include "compilefiles.h"
#include "struct.h"
#include "ADCDrv.h"
#include "R3100.h"
#include "Type.h"
#include "WDT.h"
#include "CRC.h"
#include "Bluetooth.h"

extern uint32_t SendNodeCount;
extern uint32_t SendPackCount;         				//发报警包控制数，用于控制发包的时间间隔
extern  U8 GetTimeBottomCount;                     //取得实时本底次数
extern sNB	NB_BC95;
extern sBT bluetooth_data;
U32 Vcc=0;
U8 GetInf();

unsigned char BatteryCheckcount = 0;
extern unsigned char HandWakeFlag;
extern uint16_t ADCdata; //adc采集缓存
extern U8 start_get_magnetic_bottom(Pcontroler_Symple TagCng); //初始获取一次本底
extern void GoSleep(unsigned int nS);
U8 DebugInfFlag;//调试信息标志
int BatteryCount=0;

U8 Send_SX_Count=0;//发送计数，用做发送数据包顺序区分，应对因网络堵塞造成延迟导致的数据顺序混乱

extern void SpiInit();//初始化SPI
extern void IicWrite(U8 cAddr,U8 val);
extern void sleep(void);

/************************************************************************************************
Function: void inToSleep(Pcontroler_Symple TagCng) 
Description: 
note：This function was autogenerated by energyAware Tools.
Calls:          
Called By:      
Table Accessed: 
Table Updated:  
Input:               
Output:         
Return:       
Timers:  2014.01.02    
author:  ME 
************************************************************************************************/
void inToSleep(Pcontroler_Symple TagCng)
{
//	enableInterrupts();	//开中断
	nop();nop();nop();nop();nop();
	nop();nop();nop();nop();nop();
	_HALT();
	nop();nop();nop();nop();nop();
	nop();nop();nop();nop();nop();
//	disableInterrupts();	//关中断
	RTC_WakeUpCmd(DISABLE);	//关闭自动唤醒功能
}

extern unsigned char Startup_get_bottom;
extern sNBiotAT NBAtCommand;
void OutFromSleep(Pcontroler_Symple TagCng)
{
	if((NBAtCommand.NetworkStatus & 0x80) != 0x80)   
	{
		return;
	}
	if(bluetooth_data.BTEnableFlag == 0x01)
	{
		return;
	}
	if(TagCng->Config.Tag_initNB != 0x01)
	{
		return;
	}
//	if(HandWakeFlag==1)									//如果是外部IO中断，则进行手动换新检测
//	{
//		HandWakeFlag=0;
//		if(TagCng->Config.Tag_initNB == ACTIVATE)		//激活后初始化NB，采地磁本底，此处只在初次激活中断后进入
//		{
//			LED1_set;
//			TagCng->Config.Tag_initNB = LEAVE_FACTORY;
//			WriteTagParam((Pcontroler_Symple)&TagCng_symple);
//			Startup_get_bottom = 0;                 	//连接网络
//			delay(2000);
//			Send_R3100ToRW_Test();            			//获取本底
//			NB_BC95.sleep_status = 0x01;
//			LED1_clr;
//		}
//		else 
//		{
//			LED1_set;
//			delay(2000);
//			Send_R3100ToRW_Test();              		//获取本底
//			NB_BC95.sleep_status = 0x01;
//			LED1_clr;
//		}
//		
//	}
	if(Startup_get_bottom==1)                 			//设备已经被激活过，每次开机获取一次本底，并开启地磁供电
	{
		Startup_get_bottom = 0;
		delay(10);
		Send_R3100ToRW_Test();							//获取本底
	}
//	if(NB_BC95.sleep_cnt++ > NB_BC95.sleep_end_cnt)
//	{
//		NB_BC95.sleep_status = 0x01;
//	}
	AlarmJude(TagCng);
	BatteryCount--;//电池检测唤醒周期计数。
}

/*
 * Product Test
 * Describe: 产品上电后，灯亮持续3秒,等待NFC激活测试，测试内容包括 NB模块串口通信
 * R3100 数据采集
 * Data：
 */
extern unsigned char Test_Product_Flag;
extern SSensor3100 Sensor3100L;

void test_Product(Pcontroler_Symple TagCng, pNBiotAT pMyNBAT){
	unsigned long test_count = 0;
	unsigned test_status = 0;
	ROUSE_IRQ_set;
	MEG_PRW_set;
	enableInterrupts();
//	delay(2000);
	LED1_set;
	LED2_set;
	delay(500);
	while(test_count < 30){
		if(Test_Product_Flag == 1){
			Test_Product_Flag = 0;
//			TagCng->Config.Tag_status = 0x01;
			/* 测试地磁 and 测试NB串口*/
			LED1_clr;LED2_clr;
			Getdataa(TagCng,1);
			if((Sensor3100L.EMData_x != 0) 
			   && (Sensor3100L.EMData_y != 0)
				   &&(Sensor3100L.EMData_z != 0)){
				   	test_status |= 0x01;
				   }
			if(DoNBiotATCmd(pMyNBAT, AT_CMD, JUDGE_NONE, "", pMyNBAT->ATCMDData) == SUCCESS){
				test_status |= 0x02;
			}
			switch(test_status){
			  case 0x03: LED1_set;LED2_set;delay(500);LED1_clr;LED2_clr;delay(500);
			  LED1_set;LED2_set;delay(500);LED1_clr;LED2_clr;delay(500);
			  LED1_set;LED2_set;delay(500);LED1_clr;LED2_clr;delay(500);break;		// NB串口、地磁都OK Led1 Led2 都闪烁
			  case 0x02: LED2_set;delay(500);LED2_clr;delay(500);
			  LED2_set;delay(500);LED2_clr;delay(500);
			  LED2_set;delay(500);LED2_clr;delay(500);break;						//串口OK Led2 闪烁
			  case 0x01: LED1_set;delay(500);LED1_clr;delay(500);
			  LED1_set;delay(500);LED1_clr;delay(500);
			  LED1_set;delay(500);LED1_clr;delay(500);break;						// 地磁OK Led1 闪烁
			  default:LED1_set;LED2_set;//while(1);									//地磁 NB串口都有故障，灯常亮，程序停止
			}
			break;
		}
		else{
			test_count++;
			delay(100);
		}
	}
	LED1_clr;LED2_clr;
}

void mov_data(unsigned char *source,unsigned char *dist,unsigned char lenth)
{
	unsigned char i;
	for(i = 0; i< lenth;i++)
	{
		*dist++  = *source++;
	}
}

U8 BeforeData=0;
U8 AfterData=0;
void  AlarmJude(Pcontroler_Symple TagCng)//地磁变动才发数据
{
	if(TagCng->Config.TagPara.GetEMBottom_RFFlag==0x01 && NBAtCommand.SleepFlag == 0x00)//当地磁检测开关为打开时（=0x01）才检测地磁，其他值则直接跳过
	{
		Getdataa(TagCng,1);//地磁数据检测
		judge_changeOfmodule(TagCng);//车辆状态反转判断
	}
}

void  GetVcc()
{
	if ((BatteryCount)<=0)//1小时采集一次电池电压数据
	{   
		BatteryCount=1;//720;
		ADCdata=0;
		nop();nop();nop();            //适当延时
		VRAD_init();
		AD_init();
		minidelay(20);
		/*get Vref*/
		ADCdata =  Battery_Read();
		Vcc=487305/ADCdata;
		Vcc=(Vcc>251)?(Vcc-251)/2:0;//以2.5v为基准，输出值步进0.02v
		
		if(Vcc ==0)
		{ 
			// BatteryCount = 360;
			BatteryCheckcount++; 
			BatteryCount=8;
			if(BatteryCheckcount >=4)
			{
				nop();
				// TagCng_symple.Config.TagPara.GetEMBottom_RFFlag=0;//关闭地磁检测开关,更新后再打开  20170804屏蔽
				BatteryCheckcount = 0;
			}
		}
		else if (Vcc>=63)
		{
			Vcc=63;//限制显示电压最大值
			BatteryCheckcount = 0;
		}
		else
		{
			BatteryCheckcount = 0;
		}
	}
}

U8 GetInf()
{
	U8 test;
	test=DebugInfFlag<<6;
	switch(DebugInfFlag)//调试信息标志
	{
	  case 0://电池电压
		{  
			GetVcc();//取得电池电压
			test= test | (U8)Vcc;
			nop();
			break;         
		}
	  case 1://报警信息//修复本底时间//本底调整次数
		{
			//test= test | TagCng->Config.TagNode.remot_power;   //功率
			test= test | (GetTimeBottomCount%64); 
			break;
		}
	  case 2://碰撞次数
		{
			//    test= test | (CrashCount%64);
			test= test | (BatteryCheckcount%64);
			break;
		}
	  case 3://软件版本
		{
			test= test | SYSVER;
			break;
		}
	}
	++DebugInfFlag;
	DebugInfFlag = (DebugInfFlag%4);
	return test;
}

unsigned char SendCarStatus(Pcontroler_Symple TagCng,unsigned char CarStatus)
{
	U8 test;
	U8 InfData=0;
	
	TagCng->Config.TagPara.AlarmStatus=TagCng->Config.TagPara.AlarmStatus&0x00;//初始化报警位状态
	if(CarStatus==1)
	{
		TagCng->Config.TagPara.AlarmStatus = TagCng->Config.TagPara.AlarmStatus|0x0400;//有车
	}
	else
	{
		TagCng->Config.TagPara.AlarmStatus = TagCng->Config.TagPara.AlarmStatus|0x0800;//无车
	}
	
	if (TagCng->Config.TagPara.FastRouseAlarm>20)
	{
		TagCng->Config.TagPara.FastRouseAlarm=0;
		TagCng->Config.TagPara.AlarmStatus = TagCng->Config.TagPara.AlarmStatus|0x4000;//频繁唤醒报警
	}
	
	InfData=GetInf();
	
	TagCng->Config.TagPara.AlarmStatus=TagCng->Config.TagPara.AlarmStatus|(U16)InfData;//将调试信息放入报警信息中，借用报警信息低字节
	
	TagCng->Config.TagPara.AlarmValid=0x4c00 | (U16)Send_SX_Count++;//将发送计数放入报警有效位中，借用报警有效信息低字节
	if (Send_SX_Count==0)
	{
		Send_SX_Count++;
	}
	test=SendAlarmPackage(TagCng,0);
	return test;
}


void dealServerData(pNB pMyNB, Pcontroler_Symple TagCng)
{
	if((pMyNB->nb_recv_data.receive_status & 0x80) != 0x80)
	{
		return;
	}
	else
	{
		if(++pMyNB->nb_recv_data.receive_cnt > 5)
		{
			pMyNB->nb_recv_data.receive_status &= (~0xC0);
			return;
		}	
	}
	checkNBRecvBuff(pMyNB);
	
	if((pMyNB->nb_recv_data.receive_status & 0xC0) != 0xC0)
	{
		return;
	}
	pMyNB->nb_recv_data.receive_status &= (~0xC0);
	
	uint16_t local_CRC = 0,remote_CRC = 1;
	uint8_t frame_length = pMyNB->nb_recv_data.receive_buff[3];
	remote_CRC = pMyNB->nb_recv_data.receive_buff[frame_length+11] * 256 + pMyNB->nb_recv_data.receive_buff[frame_length+11+1];
	local_CRC = CRC_16(pMyNB->nb_recv_data.receive_buff, frame_length+11);
	if(remote_CRC != local_CRC)
	{
		return;
	}
	
	uint16_t user_code = pMyNB->nb_recv_data.receive_buff[0] + pMyNB->nb_recv_data.receive_buff[1] * 256;
	if(user_code != TagCng->Config.TagNode.UserCode)
	{
		return;
	}
	
	if(pMyNB->nb_recv_data.receive_buff[5] != TagCng->Config.TagNode.Tag_id_nub[0]
	   || pMyNB->nb_recv_data.receive_buff[6] != TagCng->Config.TagNode.Tag_id_nub[1]
		   ||pMyNB->nb_recv_data.receive_buff[7] != TagCng->Config.TagNode.Tag_id_nub[2])
	{
		return;
	}
	LED2_set;
	uint8_t sleep_config;
	uint16_t modify_usercode;
	sleep_config = pMyNB->nb_recv_data.receive_buff[23];
	modify_usercode = pMyNB->nb_recv_data.receive_buff[24] + (pMyNB->nb_recv_data.receive_buff[25] * 256);
	
	TagCng->Config.TagNode.UserCode = modify_usercode;
	TagCng->Config.TagNode.Tag_id_nub[0] = pMyNB->nb_recv_data.receive_buff[26];
	TagCng->Config.TagNode.Tag_id_nub[1] = pMyNB->nb_recv_data.receive_buff[27];
	TagCng->Config.TagNode.Tag_id_nub[2] = pMyNB->nb_recv_data.receive_buff[28];
	
	
	if(sleep_config == 0xFF)
	{
		TagCng_symple.Config.Tag_status = LEAVE_FACTORY;
	}
	else
	{
		pMyNB->sleep_cnt = 0;
		pMyNB->sleep_end_cnt = (sleep_config * 3600) / TagCng_symple.Config.TagPara.WdtInterval;
		pMyNB->sleep_status = 0;
	}
		
	send_data_to_NB(pMyNB, AT_NSOST, "AT+NSOST=%d,%d.%d.%d.%d,%d,%d,FF\r\n", 0, pMyNB->default_server.ip[0],
					pMyNB->default_server.ip[1], pMyNB->default_server.ip[2],	pMyNB->default_server.ip[3], 
					pMyNB->default_server.ip, 1);
	LED2_clr;
}

